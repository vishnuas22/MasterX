"# ğŸ¤– DYNAMIC AI ROUTING SYSTEM - TECHNICAL SPECIFICATION
## Continuous Benchmarking & Intelligent Provider Selection

**Version:** 1.0  
**Last Updated:** October 1, 2025  
**Status:** Design Complete - Ready to Implement

---

## ğŸ¯ OVERVIEW

### The Problem with Static Provider Selection
Traditional approaches hardcode provider selection:
```python
# âŒ Static approach - requires code changes
if task == \"coding\":
    provider = ClaudeProvider()
elif task == \"math\":
    provider = GeminiProvider()
```

**Problems:**
- Adding new models requires code changes
- Can't adapt to model improvements
- No real performance data
- Assumptions may be wrong
- Difficult to maintain

### Our Dynamic Solution
```python
# âœ… Dynamic approach - zero code changes
provider = await smart_router.select_best_provider(
    task_category=auto_detected_category,
    emotion_state=emotion_result,
    session_context=session
)
```

**Benefits:**
- Add models by editing .env only
- Self-optimizes based on real benchmarks
- Data-driven decisions
- Always uses best performer
- Future-proof

---

## ğŸ—ï¸ SYSTEM ARCHITECTURE

### Component Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PROVIDER MANAGER                          â”‚
â”‚                 (Main Orchestrator)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚                            â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚  AUTO-DISCOVERYâ”‚          â”‚  SMART ROUTER   â”‚
       â”‚    REGISTRY    â”‚          â”‚  (Benchmark-    â”‚
       â”‚                â”‚          â”‚   based)        â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚                            â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚   UNIVERSAL    â”‚          â”‚   BENCHMARK     â”‚
       â”‚   PROVIDER     â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚    ENGINE       â”‚
       â”‚   INTERFACE    â”‚          â”‚  (Continuous    â”‚
       â”‚                â”‚          â”‚   Testing)      â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚                            â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚              MONGODB STORAGE                  â”‚
       â”‚  - Benchmark Results                          â”‚
       â”‚  - Performance History                        â”‚
       â”‚  - Session Assignments                        â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ DETAILED COMPONENT SPECIFICATIONS

### 1. Provider Registry (Auto-Discovery)

#### Responsibility
Automatically discover and register AI providers from environment variables.

#### Configuration Format (.env)
```bash
# Pattern: {PROVIDER}_API_KEY and {PROVIDER}_MODEL_NAME

# OpenAI
OPENAI_API_KEY=sk-proj-...
OPENAI_MODEL_NAME=gpt-4o
OPENAI_BASE_URL=https://api.openai.com/v1  # Optional

# Anthropic
ANTHROPIC_API_KEY=sk-ant-...
ANTHROPIC_MODEL_NAME=claude-sonnet-4

# Google Gemini
GEMINI_API_KEY=AIza...
GEMINI_MODEL_NAME=gemini-2.0-flash-exp

# Groq
GROQ_API_KEY=gsk_...
GROQ_MODEL_NAME=llama-3.3-70b-versatile

# Emergent (Universal Key)
EMERGENT_LLM_KEY=sk-emergent-...
EMERGENT_MODEL_NAME=gpt-4o

# Together AI
TOGETHER_API_KEY=...
TOGETHER_MODEL_NAME=meta-llama/Meta-Llama-3.1-70B-Instruct-Turbo

# Perplexity
PERPLEXITY_API_KEY=pplx-...
PERPLEXITY_MODEL_NAME=llama-3.1-sonar-large-128k-online

# DeepSeek
DEEPSEEK_API_KEY=sk-...
DEEPSEEK_MODEL_NAME=deepseek-chat

# Mistral
MISTRAL_API_KEY=...
MISTRAL_MODEL_NAME=mistral-large-latest

# Cohere
COHERE_API_KEY=...
COHERE_MODEL_NAME=command-r-plus

# Add unlimited more - system adapts!
```

#### Discovery Algorithm
```python
class ProviderRegistry:
    \"\"\"Auto-discover providers from environment variables\"\"\"
    
    def __init__(self):
        self.providers: Dict[str, ProviderConfig] = {}
        self.discover_providers()
    
    def discover_providers(self) -> Dict[str, ProviderConfig]:
        \"\"\"
        Scan environment for provider configurations.
        Pattern: {NAME}_API_KEY + {NAME}_MODEL_NAME
        \"\"\"
        discovered = {}
        env_vars = os.environ.keys()
        
        # Find all API key variables
        api_key_vars = [v for v in env_vars if v.endswith('_API_KEY') or v.endswith('_LLM_KEY')]
        
        for key_var in api_key_vars:
            # Extract provider name
            if key_var.endswith('_API_KEY'):
                provider_name = key_var.replace('_API_KEY', '')
            else:
                provider_name = key_var.replace('_LLM_KEY', '')
            
            # Look for corresponding model name
            model_var = f\"{provider_name}_MODEL_NAME\"
            
            if model_var in env_vars:
                api_key = os.getenv(key_var)
                model_name = os.getenv(model_var)
                base_url = os.getenv(f\"{provider_name}_BASE_URL\")  # Optional
                
                discovered[provider_name.lower()] = ProviderConfig(
                    name=provider_name.lower(),
                    api_key=api_key,
                    model_name=model_name,
                    base_url=base_url,
                    enabled=True,
                    discovered_at=datetime.utcnow()
                )
                
                logger.info(f\"âœ… Discovered provider: {provider_name.lower()} ({model_name})\")
            else:
                logger.warning(f\"âš ï¸ Found {key_var} but no {model_var}\")
        
        self.providers = discovered
        return discovered
    
    def get_provider(self, name: str) -> Optional[ProviderConfig]:
        \"\"\"Get provider configuration by name\"\"\"
        return self.providers.get(name.lower())
    
    def get_all_providers(self) -> List[ProviderConfig]:
        \"\"\"Get all discovered providers\"\"\"
        return list(self.providers.values())
    
    def is_provider_available(self, name: str) -> bool:
        \"\"\"Check if provider is available\"\"\"
        provider = self.providers.get(name.lower())
        return provider is not None and provider.enabled
```

#### Data Model
```python
@dataclass
class ProviderConfig:
    \"\"\"Configuration for a discovered provider\"\"\"
    name: str
    api_key: str
    model_name: str
    base_url: Optional[str] = None
    enabled: bool = True
    discovered_at: datetime = field(default_factory=datetime.utcnow)
    
    # Runtime metadata
    total_requests: int = 0
    total_failures: int = 0
    avg_response_time_ms: float = 0.0
    last_used: Optional[datetime] = None
```

---

### 2. Universal Provider Interface

#### Responsibility
Unified interface to communicate with any AI provider, regardless of their specific API.

#### Implementation
```python
class UniversalProvider:
    \"\"\"Unified interface for all AI providers\"\"\"
    
    def __init__(self, registry: ProviderRegistry):
        self.registry = registry
        self._clients = {}  # Cache initialized clients
    
    async def generate(
        self,
        provider_name: str,
        prompt: str,
        max_tokens: int = 2000,
        temperature: float = 0.7,
        **kwargs
    ) -> AIResponse:
        \"\"\"
        Generate response from specified provider.
        Handles provider-specific API differences.
        \"\"\"
        provider_config = self.registry.get_provider(provider_name)
        
        if not provider_config:
            raise ValueError(f\"Provider {provider_name} not found\")
        
        # Route to appropriate implementation
        if provider_name in ['openai', 'emergent']:
            return await self._openai_compatible_generate(
                provider_config, prompt, max_tokens, temperature
            )
        elif provider_name == 'anthropic':
            return await self._anthropic_generate(
                provider_config, prompt, max_tokens, temperature
            )
        elif provider_name == 'gemini':
            return await self._gemini_generate(
                provider_config, prompt, max_tokens, temperature
            )
        elif provider_name == 'groq':
            return await self._groq_generate(
                provider_config, prompt, max_tokens, temperature
            )
        elif provider_name in ['together', 'perplexity', 'deepseek', 'mistral']:
            # These use OpenAI-compatible APIs
            return await self._openai_compatible_generate(
                provider_config, prompt, max_tokens, temperature
            )
        else:
            raise NotImplementedError(f\"Provider {provider_name} not yet supported\")
    
    async def _openai_compatible_generate(
        self,
        config: ProviderConfig,
        prompt: str,
        max_tokens: int,
        temperature: float
    ) -> AIResponse:
        \"\"\"Handle OpenAI-compatible APIs\"\"\"
        from openai import AsyncOpenAI
        
        # Initialize client (cached)
        if config.name not in self._clients:
            self._clients[config.name] = AsyncOpenAI(
                api_key=config.api_key,
                base_url=config.base_url
            )
        
        client = self._clients[config.name]
        
        start_time = time.time()
        
        try:
            response = await client.chat.completions.create(
                model=config.model_name,
                messages=[{\"role\": \"user\", \"content\": prompt}],
                max_tokens=max_tokens,
                temperature=temperature
            )
            
            elapsed_ms = (time.time() - start_time) * 1000
            
            return AIResponse(
                content=response.choices[0].message.content,
                provider=config.name,
                model=config.model_name,
                tokens_used=response.usage.total_tokens,
                response_time_ms=elapsed_ms,
                success=True
            )
        
        except Exception as e:
            elapsed_ms = (time.time() - start_time) * 1000
            logger.error(f\"Error from {config.name}: {str(e)}\")
            
            return AIResponse(
                content=\"\",
                provider=config.name,
                model=config.model_name,
                tokens_used=0,
                response_time_ms=elapsed_ms,
                success=False,
                error=str(e)
            )
    
    async def _anthropic_generate(self, config, prompt, max_tokens, temperature) -> AIResponse:
        \"\"\"Handle Anthropic Claude API\"\"\"
        from anthropic import AsyncAnthropic
        
        if config.name not in self._clients:
            self._clients[config.name] = AsyncAnthropic(api_key=config.api_key)
        
        client = self._clients[config.name]
        start_time = time.time()
        
        try:
            response = await client.messages.create(
                model=config.model_name,
                max_tokens=max_tokens,
                temperature=temperature,
                messages=[{\"role\": \"user\", \"content\": prompt}]
            )
            
            elapsed_ms = (time.time() - start_time) * 1000
            
            return AIResponse(
                content=response.content[0].text,
                provider=config.name,
                model=config.model_name,
                tokens_used=response.usage.input_tokens + response.usage.output_tokens,
                response_time_ms=elapsed_ms,
                success=True
            )
        except Exception as e:
            elapsed_ms = (time.time() - start_time) * 1000
            return AIResponse(
                content=\"\",
                provider=config.name,
                model=config.model_name,
                tokens_used=0,
                response_time_ms=elapsed_ms,
                success=False,
                error=str(e)
            )
    
    async def _gemini_generate(self, config, prompt, max_tokens, temperature) -> AIResponse:
        \"\"\"Handle Google Gemini API\"\"\"
        import google.generativeai as genai
        
        genai.configure(api_key=config.api_key)
        model = genai.GenerativeModel(config.model_name)
        
        start_time = time.time()
        
        try:
            response = await model.generate_content_async(
                prompt,
                generation_config=genai.GenerationConfig(
                    max_output_tokens=max_tokens,
                    temperature=temperature
                )
            )
            
            elapsed_ms = (time.time() - start_time) * 1000
            
            return AIResponse(
                content=response.text,
                provider=config.name,
                model=config.model_name,
                tokens_used=response.usage_metadata.total_token_count if hasattr(response, 'usage_metadata') else 0,
                response_time_ms=elapsed_ms,
                success=True
            )
        except Exception as e:
            elapsed_ms = (time.time() - start_time) * 1000
            return AIResponse(
                content=\"\",
                provider=config.name,
                model=config.model_name,
                tokens_used=0,
                response_time_ms=elapsed_ms,
                success=False,
                error=str(e)
            )
    
    async def _groq_generate(self, config, prompt, max_tokens, temperature) -> AIResponse:
        \"\"\"Handle Groq API\"\"\"
        from groq import AsyncGroq
        
        if config.name not in self._clients:
            self._clients[config.name] = AsyncGroq(api_key=config.api_key)
        
        client = self._clients[config.name]
        start_time = time.time()
        
        try:
            response = await client.chat.completions.create(
                model=config.model_name,
                messages=[{\"role\": \"user\", \"content\": prompt}],
                max_tokens=max_tokens,
                temperature=temperature
            )
            
            elapsed_ms = (time.time() - start_time) * 1000
            
            return AIResponse(
                content=response.choices[0].message.content,
                provider=config.name,
                model=config.model_name,
                tokens_used=response.usage.total_tokens,
                response_time_ms=elapsed_ms,
                success=True
            )
        except Exception as e:
            elapsed_ms = (time.time() - start_time) * 1000
            return AIResponse(
                content=\"\",
                provider=config.name,
                model=config.model_name,
                tokens_used=0,
                response_time_ms=elapsed_ms,
                success=False,
                error=str(e)
            )
```

---

### 3. Benchmark Engine

#### Responsibility
Continuously test all providers across task categories to determine best performers.

#### Benchmark Categories & Test Suite

```python
BENCHMARK_CATEGORIES = {
    \"coding\": {
        \"description\": \"Code generation, debugging, algorithms\",
        \"tests\": [
            {
                \"id\": \"coding_001\",
                \"prompt\": \"Explain how merge sort algorithm works with time complexity\",
                \"expected_keywords\": [\"divide\", \"conquer\", \"merge\", \"O(n log n)\", \"recursive\"],
                \"min_length\": 150,
                \"scoring_rubric\": {
                    \"correctness\": 0.4,
                    \"clarity\": 0.3,
                    \"completeness\": 0.3
                }
            },
            {
                \"id\": \"coding_002\",
                \"prompt\": \"Debug this Python code and explain the error:
```python
for i in range(10):
    print(i)
  print('Done')
```\",
                \"expected_keywords\": [\"indentation\", \"error\", \"indent\", \"spaces\"],
                \"correct_answer_contains\": \"IndentationError\"
            },
            {
                \"id\": \"coding_003\",
                \"prompt\": \"Write a Python function that reverses a string without using built-in reverse functions\",
                \"expected_output_format\": \"function\",
                \"must_contain\": [\"def \", \"return\"]
            }
        ],
        \"weights\": {
            \"quality\": 0.5,
            \"speed\": 0.3,
            \"cost\": 0.2
        }
    },
    
    \"math\": {
        \"description\": \"Mathematical problem solving and explanations\",
        \"tests\": [
            {
                \"id\": \"math_001\",
                \"prompt\": \"Solve: 2x + 5 = 15. Show all steps.\",
                \"expected_answer\": \"5\",
                \"expected_keywords\": [\"subtract\", \"5\", \"divide\", \"2\", \"x = 5\"],
                \"min_steps\": 3
            },
            {
                \"id\": \"math_002\",
                \"prompt\": \"Explain what a derivative is in calculus, simply for a beginner\",
                \"expected_keywords\": [\"rate\", \"change\", \"slope\", \"tangent\"],
                \"min_length\": 100
            },
            {
                \"id\": \"math_003\",
                \"prompt\": \"Calculate the area of a circle with radius 7. Show formula.\",
                \"expected_answer\": \"153.9\",
                \"must_contain\": [\"Ï€\", \"rÂ²\", \"49\"]
            }
        ],
        \"weights\": {
            \"quality\": 0.6,
            \"speed\": 0.3,
            \"cost\": 0.1
        }
    },
    
    \"research\": {
        \"description\": \"Deep analysis, research, citations\",
        \"tests\": [
            {
                \"id\": \"research_001\",
                \"prompt\": \"Analyze the impact of AI on modern education. Provide evidence-based insights.\",
                \"expected_keywords\": [\"research\", \"study\", \"evidence\", \"data\", \"impact\"],
                \"min_length\": 300,
                \"depth_required\": \"high\"
            },
            {
                \"id\": \"research_002\",
                \"prompt\": \"Compare and contrast quantum computing versus classical computing\",
                \"expected_keywords\": [\"quantum\", \"classical\", \"qubit\", \"bit\", \"difference\", \"advantage\"],
                \"min_length\": 250
            }
        ],
        \"weights\": {
            \"quality\": 0.7,
            \"speed\": 0.2,
            \"cost\": 0.1
        }
    },
    
    \"language\": {
        \"description\": \"Grammar, writing, translation, language learning\",
        \"tests\": [
            {
                \"id\": \"language_001\",
                \"prompt\": \"Correct this sentence: 'Me and him goes to the store yesterday'\",
                \"expected_answer\": \"He and I went to the store yesterday\",
                \"expected_keywords\": [\"He and I\", \"went\"]
            },
            {
                \"id\": \"language_002\",
                \"prompt\": \"Translate to Spanish: 'I love learning new languages'\",
                \"expected_answer\": \"Me encanta aprender nuevos idiomas\",
                \"language\": \"spanish\"
            }
        ],
        \"weights\": {
            \"quality\": 0.5,
            \"speed\": 0.4,
            \"cost\": 0.1
        }
    },
    
    \"empathy\": {
        \"description\": \"Emotional support, encouragement, motivation\",
        \"tests\": [
            {
                \"id\": \"empathy_001\",
                \"prompt\": \"I'm really frustrated with this math problem and want to give up\",
                \"expected_tone\": \"supportive\",
                \"expected_keywords\": [\"understand\", \"difficult\", \"can\", \"help\", \"together\"],
                \"should_avoid\": [\"easy\", \"simple\", \"just\"]
            },
            {
                \"id\": \"empathy_002\",
                \"prompt\": \"I failed my test again. I feel like I'm not smart enough.\",
                \"expected_tone\": \"encouraging\",
                \"expected_keywords\": [\"capable\", \"growth\", \"learn\", \"practice\", \"progress\"],
                \"should_avoid\": [\"stupid\", \"dumb\", \"failure\"]
            }
        ],
        \"weights\": {
            \"quality\": 0.8,  # Empathy quality is critical
            \"speed\": 0.2,
            \"cost\": 0.0      # Cost doesn't matter for emotional support
        }
    },
    
    \"general\": {
        \"description\": \"General conversation, Q&A, summaries\",
        \"tests\": [
            {
                \"id\": \"general_001\",
                \"prompt\": \"What is photosynthesis?\",
                \"expected_keywords\": [\"plants\", \"light\", \"energy\", \"chlorophyll\", \"oxygen\"],
                \"min_length\": 100
            },
            {
                \"id\": \"general_002\",
                \"prompt\": \"Summarize the water cycle in 3 sentences\",
                \"max_length\": 200,
                \"expected_keywords\": [\"evaporation\", \"condensation\", \"precipitation\"]
            }
        ],
        \"weights\": {
            \"quality\": 0.5,
            \"speed\": 0.4,
            \"cost\": 0.1
        }
    }
}
```

#### Benchmark Execution
```python
class BenchmarkEngine:
    \"\"\"Continuous benchmarking system\"\"\"
    
    def __init__(
        self,
        registry: ProviderRegistry,
        universal_provider: UniversalProvider,
        db_collection
    ):
        self.registry = registry
        self.universal = universal_provider
        self.benchmarks_collection = db_collection
        self.is_running = False
    
    async def run_benchmarks(
        self,
        categories: Optional[List[str]] = None,
        providers: Optional[List[str]] = None
    ) -> Dict[str, Dict[str, BenchmarkResult]]:
        \"\"\"
        Run benchmarks across all providers and categories.
        
        Args:
            categories: List of categories to test (None = all)
            providers: List of providers to test (None = all discovered)
        
        Returns:
            Dict[category][provider] = BenchmarkResult
        \"\"\"
        if self.is_running:
            logger.warning(\"Benchmarks already running, skipping...\")
            return {}
        
        self.is_running = True
        logger.info(\"ğŸš€ Starting benchmark run...\")
        
        # Determine what to test
        test_categories = categories or list(BENCHMARK_CATEGORIES.keys())
        test_providers = providers or list(self.registry.providers.keys())
        
        results = {}
        timestamp = datetime.utcnow()
        
        for category in test_categories:
            results[category] = {}
            category_config = BENCHMARK_CATEGORIES[category]
            
            logger.info(f\"  Testing category: {category}\")
            
            for provider_name in test_providers:
                logger.info(f\"    Testing provider: {provider_name}\")
                
                # Run all tests for this provider+category
                test_results = await self._run_category_tests(
                    provider_name,
                    category,
                    category_config['tests']
                )
                
                # Calculate aggregate scores
                benchmark_result = self._calculate_scores(
                    provider_name,
                    category,
                    test_results,
                    category_config['weights']
                )
                
                results[category][provider_name] = benchmark_result
                
                # Save to database
                await self._save_benchmark_result(
                    category,
                    provider_name,
                    benchmark_result,
                    timestamp
                )
        
        self.is_running = False
        logger.info(\"âœ… Benchmark run complete!\")
        
        return results
    
    async def _run_category_tests(
        self,
        provider_name: str,
        category: str,
        tests: List[Dict]
    ) -> List[TestResult]:
        \"\"\"Run all tests in a category for one provider\"\"\"
        results = []
        
        for test in tests:
            try:
                # Generate response
                response = await self.universal.generate(
                    provider_name=provider_name,
                    prompt=test['prompt'],
                    max_tokens=2000,
                    temperature=0.7
                )
                
                # Evaluate response quality
                quality_score = await self._evaluate_quality(response, test)
                
                results.append(TestResult(
                    test_id=test['id'],
                    response=response,
                    quality_score=quality_score,
                    passed=quality_score >= 60  # 60% threshold
                ))
                
            except Exception as e:
                logger.error(f\"Test {test['id']} failed for {provider_name}: {e}\")
                results.append(TestResult(
                    test_id=test['id'],
                    response=None,
                    quality_score=0,
                    passed=False,
                    error=str(e)
                ))
        
        return results
    
    async def _evaluate_quality(
        self,
        response: AIResponse,
        test: Dict
    ) -> float:
        \"\"\"
        Evaluate response quality (0-100 score).
        
        Checks:
        - Contains expected keywords
        - Correct answer (if applicable)
        - Appropriate length
        - Avoids problematic phrases
        - Tone matches expectations
        \"\"\"
        score = 0.0
        max_score = 100.0
        
        if not response.success or not response.content:
            return 0.0
        
        content = response.content.lower()
        
        # Check expected keywords (40 points)
        if 'expected_keywords' in test:
            keywords = test['expected_keywords']
            found = sum(1 for kw in keywords if kw.lower() in content)
            score += (found / len(keywords)) * 40
        
        # Check correct answer (30 points)
        if 'expected_answer' in test:
            if test['expected_answer'].lower() in content:
                score += 30
        
        # Check minimum length (10 points)
        if 'min_length' in test:
            if len(response.content) >= test['min_length']:
                score += 10
            else:
                score += (len(response.content) / test['min_length']) * 10
        
        # Check must contain (10 points)
        if 'must_contain' in test:
            phrases = test['must_contain']
            found = sum(1 for phrase in phrases if phrase.lower() in content)
            score += (found / len(phrases)) * 10
        
        # Check should avoid (deduct 20 points)
        if 'should_avoid' in test:
            avoid = test['should_avoid']
            found_bad = sum(1 for phrase in avoid if phrase.lower() in content)
            if found_bad > 0:
                score -= 20
        
        # Tone check for empathy (10 points)
        if 'expected_tone' in test:
            if test['expected_tone'] == 'supportive':
                supportive_words = ['understand', 'help', 'together', 'support']
                found = sum(1 for word in supportive_words if word in content)
                score += min(found * 2.5, 10)
        
        return max(0, min(score, max_score))
    
    def _calculate_scores(
        self,
        provider_name: str,
        category: str,
        test_results: List[TestResult],
        weights: Dict[str, float]
    ) -> BenchmarkResult:
        \"\"\"Calculate aggregate scores for provider in category\"\"\"
        
        # Quality score (average of all test scores)
        quality_scores = [r.quality_score for r in test_results if r.quality_score is not None]
        avg_quality = np.mean(quality_scores) if quality_scores else 0
        
        # Speed score (average response time)
        response_times = [r.response.response_time_ms for r in test_results if r.response]
        avg_time_ms = np.mean(response_times) if response_times else 99999
        
        # Cost score (estimated cost per request)
        token_counts = [r.response.tokens_used for r in test_results if r.response]
        avg_tokens = np.mean(token_counts) if token_counts else 0
        avg_cost = self._estimate_cost(provider_name, avg_tokens)
        
        # Normalize scores (0-100)
        speed_score = min(100, 10000 / avg_time_ms) if avg_time_ms > 0 else 0
        cost_score = min(100, 0.001 / avg_cost) if avg_cost > 0 else 100
        
        # Calculate weighted final score
        final_score = (
            weights['quality'] * avg_quality +
            weights['speed'] * speed_score +
            weights['cost'] * cost_score
        )
        
        return BenchmarkResult(
            provider=provider_name,
            category=category,
            quality_score=avg_quality,
            speed_score=speed_score,
            cost_score=cost_score,
            final_score=final_score,
            avg_response_time_ms=avg_time_ms,
            avg_cost=avg_cost,
            tests_passed=sum(1 for r in test_results if r.passed),
            tests_total=len(test_results),
            timestamp=datetime.utcnow()
        )
    
    def _estimate_cost(self, provider_name: str, tokens: float) -> float:
        \"\"\"Estimate cost per request (approximate pricing)\"\"\"
        # Rough pricing estimates (update with actual pricing)
        pricing = {
            'openai': 0.00001 * tokens,  # GPT-4o
            'anthropic': 0.000015 * tokens,  # Claude Sonnet
            'gemini': 0.0000025 * tokens,  # Gemini Flash
            'groq': 0.0000001 * tokens,  # Groq (very cheap)
            'emergent': 0.00001 * tokens,  # Similar to OpenAI
        }
        return pricing.get(provider_name, 0.00001 * tokens)
    
    async def _save_benchmark_result(
        self,
        category: str,
        provider: str,
        result: BenchmarkResult,
        timestamp: datetime
    ):
        \"\"\"Save benchmark result to MongoDB\"\"\"
        await self.benchmarks_collection.insert_one({
            'category': category,
            'provider': provider,
            'quality_score': result.quality_score,
            'speed_score': result.speed_score,
            'cost_score': result.cost_score,
            'final_score': result.final_score,
            'avg_response_time_ms': result.avg_response_time_ms,
            'avg_cost': result.avg_cost,
            'tests_passed': result.tests_passed,
            'tests_total': result.tests_total,
            'timestamp': timestamp,
            'date': timestamp.date().isoformat()
        })
    
    async def get_latest_benchmarks(
        self,
        category: str,
        max_age_hours: int = 24
    ) -> List[BenchmarkResult]:
        \"\"\"Get latest benchmark results for a category\"\"\"
        cutoff = datetime.utcnow() - timedelta(hours=max_age_hours)
        
        cursor = self.benchmarks_collection.find({
            'category': category,
            'timestamp': {'$gte': cutoff}
        }).sort('timestamp', -1)
        
        results = []
        async for doc in cursor:
            results.append(BenchmarkResult(
                provider=doc['provider'],
                category=doc['category'],
                quality_score=doc['quality_score'],
                speed_score=doc['speed_score'],
                cost_score=doc['cost_score'],
                final_score=doc['final_score'],
                avg_response_time_ms=doc['avg_response_time_ms'],
                avg_cost=doc['avg_cost'],
                tests_passed=doc['tests_passed'],
                tests_total=doc['tests_total'],
                timestamp=doc['timestamp']
            ))
        
        return results
    
    async def schedule_benchmarks(self, interval_hours: int = 1):
        \"\"\"Run benchmarks periodically in background\"\"\"
        while True:
            try:
                await self.run_benchmarks()
                logger.info(f\"Next benchmark run in {interval_hours} hour(s)\")
                await asyncio.sleep(interval_hours * 3600)
            except Exception as e:
                logger.error(f\"Benchmark error: {e}\")
                await asyncio.sleep(300)  # Wait 5 min on error
```

---

### 4. Smart Router

#### Responsibility
Select the best provider for each request based on latest benchmarks, emotion state, and session context.

#### Implementation
```python
class SmartRouter:
    \"\"\"Intelligent provider selection based on benchmarks\"\"\"
    
    def __init__(
        self,
        benchmark_engine: BenchmarkEngine,
        session_manager: SessionManager
    ):
        self.benchmark_engine = benchmark_engine
        self.session_manager = session_manager
    
    async def select_provider(
        self,
        message: str,
        emotion_state: EmotionResult,
        session_id: str,
        context: ConversationContext
    ) -> str:
        \"\"\"
        Select best provider for this request.
        
        Decision factors:
        1. Session continuity (stick with same provider for same topic)
        2. Task category (detected from message)
        3. Emotion state (use empathetic provider if frustrated)
        4. Latest benchmark scores
        5. Provider availability (circuit breaker)
        \"\"\"
        
        # 1. Check session continuity
        session_info = await self.session_manager.get_session_info(session_id)
        
        if session_info and session_info.get('current_provider'):
            # Check if topic changed
            topic_changed = await self._detect_topic_change(
                message,
                session_info.get('current_topic'),
                context
            )
            
            if not topic_changed:
                # Continue with same provider
                logger.info(f\"Continuing with {session_info['current_provider']} (same topic)\")
                return session_info['current_provider']
        
        # 2. Detect task category
        task_category = await self._detect_category(message, emotion_state, context)
        
        # 3. Get latest benchmarks for this category
        benchmarks = await self.benchmark_engine.get_latest_benchmarks(
            category=task_category,
            max_age_hours=24
        )
        
        if not benchmarks:
            # No recent benchmarks, use default
            logger.warning(f\"No benchmarks for {task_category}, using default\")
            return self._get_default_provider()
        
        # 4. Filter available providers (circuit breaker)
        available = [b for b in benchmarks if circuit_breaker.is_available(b.provider)]
        
        if not available:
            logger.error(\"No providers available!\")
            return self._get_default_provider()
        
        # 5. Sort by score and select best
        available.sort(key=lambda x: x.final_score, reverse=True)
        best_provider = available[0].provider
        
        # 6. Update session context
        await self.session_manager.update_session(
            session_id,
            provider=best_provider,
            topic=task_category
        )
        
        logger.info(f\"Selected {best_provider} for {task_category} (score: {available[0].final_score:.1f})\")
        
        return best_provider
    
    async def _detect_category(
        self,
        message: str,
        emotion_state: EmotionResult,
        context: ConversationContext
    ) -> str:
        \"\"\"
        Detect task category from message.
        Uses keyword matching + context clues.
        \"\"\"
        msg_lower = message.lower()
        
        # Check for frustrated emotion first
        if emotion_state.primary_emotion in ['frustration', 'anxiety', 'sadness']:
            return 'empathy'
        
        # Keyword-based detection
        coding_keywords = ['code', 'function', 'algorithm', 'programming', 'python', 'javascript', 'debug', 'error', 'syntax']
        math_keywords = ['solve', 'calculate', 'equation', 'derivative', 'integral', 'geometry', 'algebra']
        research_keywords = ['analyze', 'research', 'compare', 'study', 'evidence', 'paper', 'theory']
        language_keywords = ['translate', 'grammar', 'correct', 'sentence', 'spanish', 'french', 'language']
        
        if any(kw in msg_lower for kw in coding_keywords):
            return 'coding'
        elif any(kw in msg_lower for kw in math_keywords):
            return 'math'
        elif any(kw in msg_lower for kw in research_keywords):
            return 'research'
        elif any(kw in msg_lower for kw in language_keywords):
            return 'language'
        else:
            return 'general'
    
    async def _detect_topic_change(
        self,
        new_message: str,
        current_topic: Optional[str],
        context: ConversationContext
    ) -> bool:
        \"\"\"Detect if user switched topics\"\"\"
        if not current_topic:
            return True
        
        new_category = await self._detect_category(new_message, None, context)
        return new_category != current_topic
    
    def _get_default_provider(self) -> str:
        \"\"\"Fallback provider when no benchmarks available\"\"\"
        # Use fastest provider (Groq) as default
        return 'groq'
```

---

### 5. Session Manager

#### Responsibility
Maintain provider consistency within topics/sessions.

```python
class SessionManager:
    \"\"\"Manage provider assignments per session\"\"\"
    
    def __init__(self, db_collection):
        self.sessions_collection = db_collection
    
    async def get_session_info(self, session_id: str) -> Optional[Dict]:
        \"\"\"Get current session information\"\"\"
        return await self.sessions_collection.find_one({'session_id': session_id})
    
    async def update_session(
        self,
        session_id: str,
        provider: str,
        topic: str
    ):
        \"\"\"Update session with provider and topic\"\"\"
        await self.sessions_collection.update_one(
            {'session_id': session_id},
            {
                '$set': {
                    'current_provider': provider,
                    'current_topic': topic,
                    'updated_at': datetime.utcnow()
                }
            },
            upsert=True
        )
```

---

## ğŸš€ IMPLEMENTATION PHASES

### Phase 1: Basic Auto-Discovery (Week 1, Day 2-3)
- Build ProviderRegistry with auto-discovery
- Build UniversalProvider with 3 providers (Groq, Emergent, Gemini)
- Simple round-robin or random selection
- Test that it works

### Phase 2: Benchmarking System (Week 2, Day 1-3)
- Build BenchmarkEngine
- Create test suite for 3 categories (coding, math, empathy)
- Run benchmarks manually
- Store results in MongoDB

### Phase 3: Smart Routing (Week 2, Day 4-5)
- Build SmartRouter
- Route based on benchmark scores
- Add session management
- Test category detection

### Phase 4: Continuous Benchmarking (Week 3, Day 1-2)
- Schedule benchmarks every 1-12 hours
- Background task execution
- Results monitoring dashboard (optional)

### Phase 5: Scale & Optimize (Week 3+)
- Add more providers (7-10 total)
- Expand test categories
- A/B testing support
- Cost optimization algorithms

---

## ğŸ“Š EXAMPLE WORKFLOW

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User: \"I'm struggling with this sorting algorithm\"          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
                    â”‚  DETECT  â”‚
                    â”‚ EMOTION  â”‚
                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â”œâ”€â–º Primary: frustration
                         â”‚
                    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
                    â”‚ DETECT   â”‚
                    â”‚ CATEGORY â”‚
                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â”œâ”€â–º Category: empathy (due to frustration)
                         â”‚   (Not coding, because emotion takes priority)
                         â”‚
                    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
                    â”‚  CHECK   â”‚
                    â”‚ SESSION  â”‚
                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â”œâ”€â–º No existing provider for this topic
                         â”‚
                    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
                    â”‚   GET    â”‚
                    â”‚BENCHMARKSâ”‚
                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â”œâ”€â–º Latest empathy benchmarks:
                         â”‚   1. Claude Sonnet 4: 94.2
                         â”‚   2. GPT-4o: 91.8
                         â”‚   3. Gemini Pro: 87.3
                         â”‚
                    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
                    â”‚  SELECT  â”‚
                    â”‚  CLAUDE  â”‚
                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â”œâ”€â–º Save to session: provider=claude, topic=empathy
                         â”‚
                    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
                    â”‚ GENERATE â”‚
                    â”‚ RESPONSE â”‚
                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Claude Response: \"I understand this can be frustrating...   â”‚
â”‚ Let's break it down step by step together...\"               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User: \"OK, so how does merge sort work?\"                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”˜
                         â”‚
                    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
                    â”‚ DETECT   â”‚
                    â”‚ EMOTION  â”‚
                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â”œâ”€â–º Primary: curiosity (improved!)
                         â”‚
                    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
                    â”‚ DETECT   â”‚
                    â”‚ CATEGORY â”‚
                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â”œâ”€â–º Category: coding (now calm enough to learn)
                         â”‚
                    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
                    â”‚  CHECK   â”‚
                    â”‚ SESSION  â”‚
                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â”œâ”€â–º Topic changed (empathy â†’ coding)
                         â”‚   Need new provider!
                         â”‚
                    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
                    â”‚   GET    â”‚
                    â”‚BENCHMARKSâ”‚
                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â”œâ”€â–º Latest coding benchmarks:
                         â”‚   1. Claude Sonnet 4: 96.8
                         â”‚   2. GPT-4o: 93.2
                         â”‚   3. DeepSeek: 91.5
                         â”‚
                    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
                    â”‚  SELECT  â”‚
                    â”‚  CLAUDE  â”‚ (Still Claude, best for coding too!)
                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â”œâ”€â–º Update session: provider=claude, topic=coding
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Claude Response: \"Great question! Merge sort is a divide... â”‚
â”‚ [detailed technical explanation]\"                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## âœ… SUCCESS METRICS

### System Performance
- **Provider discovery:** < 1 second on startup
- **Benchmark execution:** < 5 minutes for all categories
- **Provider selection:** < 50ms per request
- **Session lookup:** < 10ms per request

### Quality Metrics
- **Routing accuracy:** > 90% (correct provider selected)
- **Cost reduction:** 20-40% vs. always using GPT-4
- **Quality maintenance:** > 95% (vs. best static selection)
- **Session continuity:** > 95% (same provider for same topic)

### Maintainability
- **Add new provider:** < 1 minute (just edit .env)
- **Update model:** < 1 minute (just edit .env)
- **Add new category:** < 30 minutes (add test suite)
- **Deploy changes:** Zero downtime

---

## ğŸ¯ CONCLUSION

This dynamic AI routing system provides:
1. âœ… **Zero hardcoded providers** - Configuration-driven
2. âœ… **Self-optimizing** - Continuously improves via benchmarks
3. âœ… **Maintainable** - Add/remove models without code changes
4. âœ… **Cost-effective** - Routes to cheapest equivalent provider
5. âœ… **Quality-focused** - Always uses best performer
6. âœ… **Future-proof** - Adapts to new models automatically
7. âœ… **Session-aware** - Maintains consistency within topics

**This is the most advanced, maintainable AI routing system possible.** ğŸš€

---

**Document Version:** 1.0  
**Created:** October 1, 2025  
**Status:** Ready for Implementation
"